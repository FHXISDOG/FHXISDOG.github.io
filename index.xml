<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FHXISDOG</title>
    <link>https://fhxisdog.github.io/</link>
    <description>Recent content on FHXISDOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Tue, 17 Sep 2019 13:18:09 +0800</lastBuildDate>
    
	<atom:link href="https://fhxisdog.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Error: Insufficient Permissions for Device(解决adb Shell问题)</title>
      <link>https://fhxisdog.github.io/posts/error-insufficient-permissions-for-device%E8%A7%A3%E5%86%B3adb-shell%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 17 Sep 2019 13:18:09 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/error-insufficient-permissions-for-device%E8%A7%A3%E5%86%B3adb-shell%E9%97%AE%E9%A2%98/</guid>
      <description>在linux连接android手机，使用adb出现error: insufficient permissions for device
输入 adb-devices显示:
List of devices attached 6180bb53	no permissions; see [http://developer.android.com/tools/device.html]  解决方法:
1.首先在终端查看usb的ID，输入lsusb命令，我们可以看到我们刚插如usb的ID号，如：
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub Bus 001 Device 005: ID 5986:2113 Acer, Inc Bus 001 Device 006: ID 8087:0a2a Intel Corp. Bus 001 Device 007: ID 24ae:1813 Bus 001 Device 024: ID 05c6:676c Qualcomm, Inc. //这个就是我的设备 Bus 001 Device 017: ID 0c45:8073 Microdia Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.</description>
    </item>
    
    <item>
      <title>Android Platform 28 SDK License Not Accepted</title>
      <link>https://fhxisdog.github.io/posts/android-platform-28-sdk-license-not-accepted/</link>
      <pubDate>Tue, 17 Sep 2019 13:13:09 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/android-platform-28-sdk-license-not-accepted/</guid>
      <description>&amp;gt; Configure project :core Checking the license for package Android SDK Platform 28 in /opt/android/sdk/licenses Warning: License for package Android SDK Platform 28 not accepted. FAILURE: Build failed with an exception. * What went wrong: A problem occurred configuring project &#39;:core&#39;. &amp;gt; Failed to install the following Android SDK packages as some licences have not been accepted. platforms;android-28 Android SDK Platform 28 To build this project, accept the SDK license agreements and install the missing components using the Android Studio SDK Manager.</description>
    </item>
    
    <item>
      <title>Emacs搭建python开发环境</title>
      <link>https://fhxisdog.github.io/posts/emacs%E6%90%AD%E5%BB%BApython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 15 Sep 2019 05:05:24 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/emacs%E6%90%AD%E5%BB%BApython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>安装python必须的依赖 sudo pip install jedi elpy rope pylint
emacs配置 在～/.emacs.d/路径新建文件init.el
添加以下配置:
(require &#39;package) (package-initialize) ;;配置包管理列表的源 (setq package-archives &#39;((&amp;quot;gnu&amp;quot; . &amp;quot;http://elpa.emacs-china.org/gnu/&amp;quot;) (&amp;quot;melpa&amp;quot; . &amp;quot;https://stable.melpa.org/packages/&amp;quot;))) (require &#39;cl) (defvar my/packages &#39;( company better-deafults material-theme elpy company-jedi switch-window projectile neotree ) ) ;;jedi配置 (setq jedi:setup-keys t) (setq jedi:complete-on-dot t) (setq elpy-rpc-backend &amp;quot;jedi&amp;quot;) (when (fboundp &#39;jedi:setup) (jedi:setup)) ;; 自动补全 (global-company-mode t) (add-hook &#39;after-init-hook &#39;global-company-mode) ;; 使用material主题 (load-theme &#39;material t) ;; enable python插件 (elpy-enable) ;;设置切换窗口为a-z (setq switch-window-shortcut-style &#39;qwerty) (global-set-key (kbd &amp;quot;C-x o&amp;quot;) &#39;switch-window) ;;projectilep配置 (projectile-mode +1) (define-key projectile-mode-map (kbd &amp;quot;C-c p&amp;quot;) &#39;projectile-command-map) ;;neotree配置 (setq neo-smart-open t) (setq projectile-switch-project-action &#39;neotree-projectile-action) (defun neotree-project-dir () &amp;quot;Open NeoTree using the git root.</description>
    </item>
    
    <item>
      <title>Emacs快捷键</title>
      <link>https://fhxisdog.github.io/posts/emacs%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Sat, 14 Sep 2019 16:44:17 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/emacs%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description> 含义 C -&amp;gt; CTRL
M -&amp;gt; ALT
S-&amp;gt;SHIFT
基本命令  快捷键 含义 快捷键 含义    C-x C-f 打开文件 C-x C-c 关闭emacs   C-x C-s 保存文件 C-x C-w 当前缓冲区另存为   C-g 取消命令 C-x C-b 打开缓冲区列表   C-x b  打开一个缓冲区 C-x k 关闭当前缓冲区   C-x C-v 关闭当前缓冲区并打开新的文件    移动命令  快捷键 含义 快捷键 含义    C-n 向下移动一行 C-p 向上移动一行   C-f 向前移动一个字符 C-b 向后移动一个字符   C-a 移动到行首 C-e 移动到行尾   M-b 向后移动一个单词 M-f 向前移动一个单词   M-v 向上移动半屏 C-v 向下移动半屏   M-&amp;gt; 到文件末尾 M-&amp;lt; 到文件开头   M-g M-g  跳到xx行    窗口命令  快捷键 含义 快捷键 含义    C-x 2 水平分割窗口 C-x 3 垂直分割窗口   C-x 0 关闭当前窗口 C-x 1 关闭其他窗口   C-x 4 f  新tab打开文件 C-x 5 f   新窗口打开文件   C-x o   切换窗口 C-x 5 2  新建窗口   C-M-V 向下滚动其他窗口 C-M-S-V 向上滚动窗口    编辑命令  快捷键 含义 快捷键 含义    C-space 开始设置标记 C-@ 开始设置标记   M-w 复制标记内容 C-w 剪切选中内容   M-d 删除后面一个单词 C-d 删除后面一个字符   C-y 粘贴 C-k 删除一行   M-u 后面一个单词变成大写 M-l 后一个单词变成小写   M-c 后面一个单词首字母大写    替换命令  快捷键 含义 快捷键 含义    C-s 向下搜索 C-r 向上搜索   M-% 替换    文件夹命令  快捷键 含义 快捷键 含义    C-s d 打开文件夹列表 n 向下移动   p 向上移动 v 编辑光标所在文件   d 标记为删除 D 马上删除   x 执行标记 C 拷贝当前文件   R 重命名 &amp;#43; 新建文件夹   z 压缩文件 ！ 对光标所在文件执行shell命令   q 退出    </description>
    </item>
    
    <item>
      <title>将vue打包到springboot静态资源中</title>
      <link>https://fhxisdog.github.io/posts/%E5%B0%86vue%E6%89%93%E5%8C%85%E5%88%B0springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%AD/</link>
      <pubDate>Wed, 04 Sep 2019 16:48:24 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/%E5%B0%86vue%E6%89%93%E5%8C%85%E5%88%B0springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%AD/</guid>
      <description> 项目中遇到需要将vue打包到spring boot 中的static中，直接访问，不需要使用Nginx来访问nginx.具体做法如下:
将vue工程放到spring boot工程最外层 修改pom文件  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;exec-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;!--程序打包的时候，利用本地已安装的node环境，同时编译管理后台前端的工程文件--&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;npm-build-background&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;executable&amp;gt;${npm.command}&amp;lt;/executable&amp;gt; &amp;lt;arguments&amp;gt; &amp;lt;argument&amp;gt;run&amp;lt;/argument&amp;gt; &amp;lt;argument&amp;gt;prod-package&amp;lt;/argument&amp;gt; &amp;lt;/arguments&amp;gt; &amp;lt;workingDirectory&amp;gt;${basedir}/consumable-background&amp;lt;/workingDirectory&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;!--添加管理后台前端工程的静态文件到jar包中--&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;copy-consumable-background&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;copy-resources&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;outputDirectory&amp;gt;${basedir}/target/classes/static/background&amp;lt;/outputDirectory&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;${basedir}/consumable-background/dist&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt;  配置拦截器(此步可以省略,应为springboot static 路径是默认放开的)  @Override public void addResourceHandlers(org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry registry) { registry.addResourceHandler(&amp;quot;/static/**&amp;quot;) .addResourceLocations(&amp;quot;classpath:/static/&amp;quot;); }  </description>
    </item>
    
    <item>
      <title>Spring Boot 分环境打包</title>
      <link>https://fhxisdog.github.io/posts/spring-boot-%E5%88%86%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/</link>
      <pubDate>Wed, 04 Sep 2019 16:33:58 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/spring-boot-%E5%88%86%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/</guid>
      <description>使用spring boot工程时，虽然官方提供了application.profiles.active参数去激活不同环境，但是如果打包时忘了修改还是比较麻烦的时。可以使用maven插件，自动的更新不同环境的 的配置文件。
配置方法如下:
这里列举三个环境:dev,test,prod
resource目录结构如下(custom-config.properties为自定义的配置文件,区分不同环境也是以dev,test,prod结尾,如:custom-config-dev.properties):
--- resource --- application.yml --- application-dev.yml --- application-test.yml --- application-prod.yml --- custom-config.properties --- custom-config-dev.properties --- custom-config-test.properties --- custom-config-prod.properties --- application-common.yml  修改pom文件:  &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;dev&amp;lt;/id&amp;gt; &amp;lt;activation&amp;gt; &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt; &amp;lt;/activation&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;dev&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;test&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;test&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;prod&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;prod&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt; &amp;lt;build&amp;gt; &amp;lt;finalName&amp;gt;app&amp;lt;/finalName&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;excludes&amp;gt; &amp;lt;exclude&amp;gt;application-*.yml&amp;lt;/exclude&amp;gt; &amp;lt;exclude&amp;gt;custom-config.properties&amp;lt;/exclude&amp;gt; &amp;lt;/excludes&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;!-- 是否替换@xx@表示的maven properties属性值 --&amp;gt; &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;application.</description>
    </item>
    
    <item>
      <title>Spring Boot Thymeleaf 引用contexpath</title>
      <link>https://fhxisdog.github.io/posts/spring-boot-thymeleaf-%E5%BC%95%E7%94%A8contexpath/</link>
      <pubDate>Wed, 04 Sep 2019 16:03:04 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/spring-boot-thymeleaf-%E5%BC%95%E7%94%A8contexpath/</guid>
      <description>spring boot 设置contextPath后，如果js中的请求路径不设置，会造成404的问题。 设置方法:
在html页面header中添加配置:
&amp;lt;meta name=&amp;quot;ctx&amp;quot; th:content=&amp;quot;${#httpServletRequest.getContextPath()}&amp;quot; &amp;gt;  js中引用:
 var ctx = $(&amp;quot;meta[name=&#39;ctx&#39;]&amp;quot;).attr(&amp;quot;content&amp;quot;);  变量ctx就是contextPath</description>
    </item>
    
    <item>
      <title>Manjaro安装displaylink</title>
      <link>https://fhxisdog.github.io/posts/manjaro%E5%AE%89%E8%A3%85displaylink/</link>
      <pubDate>Mon, 24 Jun 2019 13:06:10 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/manjaro%E5%AE%89%E8%A3%85displaylink/</guid>
      <description>使用华硕的便携笔记本需要安装displaylink驱动，官方又只提供windows驱动，在manjaro上使用需要自己安装驱动，经过研究，安装方法如下: 准备工作  uname -r查看内核版本,输出:4.19.23-1-MANJARO,说明我的内核版本是419,执行pacman -Ss linux-headers查看库中的依赖，执行sudo pacman -S core/liux419-headers安装头文件 安装evdi:yay -S evdi-git 3 安装displaylink yay -S displaylink  开始配置  装载evdi: sudo modprobe evdi 装载udl: sudo modprobe udl 启用displaylink.sevice: systemctl enable display link 开启displaylink.service:systemctl start displaylink 新增配置文件
/usr/share/X11/xorg.conf.d/20-evdidevice.conf --- Section &amp;quot;OutputClass&amp;quot; Identifier &amp;quot;DisplayLink&amp;quot; MatchDriver &amp;quot;evdi&amp;quot; Driver &amp;quot;modesetting&amp;quot; Option &amp;quot;AccelMethod&amp;quot; &amp;quot;none&amp;quot; EndSection  执行xandr --listproviders,可以看到输出:
Providers: number : 2 Provider 0: id: 0x45 cap: 0xb, Source Output, Sink Output, Sink Offload crtcs: 4 outputs: 2 associated providers: 1 name:Intel Provider 1: id: 0x14d cap: 0x2, Sink Output crtcs: 1 outputs: 1 associated providers: 1 name:modesetting  lxrandr开启屏幕</description>
    </item>
    
    <item>
      <title>Docker Compose：链接外部容器的几种方式</title>
      <link>https://fhxisdog.github.io/posts/docker-compose%E9%93%BE%E6%8E%A5%E5%A4%96%E9%83%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 04 Jun 2019 15:01:04 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/docker-compose%E9%93%BE%E6%8E%A5%E5%A4%96%E9%83%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>在Docker中，容器之间的链接是一种很常见的操作：它提供了访问其中的某个容器的网络服务而不需要将所需的端口暴露给Docker Host主机的功能。Docker Compose中对该特性的支持同样是很方便的。然而，如果需要链接的容器没有定义在同一个docker-compose.yml中的时候，这个时候就稍微麻烦复杂了点。
 在不使用Docker Compose的时候，将两个容器链接起来使用—link参数，相对来说比较简单，以nginx镜像为例子：
docker run --rm --name test1 -d nginx #开启一个实例test1 docker run --rm --name test2 --link test1 -d nginx #开启一个实例test2并与test1建立链接  这样，test2与test1便建立了链接，就可以在test2中使用访问test1中的服务了。
如果使用Docker Compose，那么这个事情就更简单了，还是以上面的nginx镜像为例子，编辑docker-compose.yml文件为：
version: &amp;quot;3&amp;quot; services: test2: image: nginx depends_on: - test1 links: - test1 test1: image: nginx  最终效果与使用普通的Docker命令docker run xxxx建立的链接并无区别。这只是一种最为理想的情况。
 如果容器没有定义在同一个docker-compose.yml文件中，应该如何链接它们呢？ 又如果定义在docker-compose.yml文件中的容器需要与docker run xxx启动的容器链接，需要如何处理？ 针对这两种典型的情况，下面给出我个人测试可行的办法：  方式一：让需要链接的容器同属一个外部网络 我们还是使用nginx镜像来模拟这样的一个情景：假设我们需要将两个使用Docker Compose管理的nignx容器（test1和test2）链接起来，使得test2能够访问test1中提供的服务，这里我们以能ping通为准。
首先，我们定义容器test1的docker-compose.yml文件内容为：
version: &amp;quot;3&amp;quot; services: test2: image: nginx container_name: test1 networks: - default - app_net networks: app_net: external: true  容器test2内容与test1基本一样，只是多了一个external_links,需要特别说明的是：最近发布的Docker版本已经不需要使用external_links来链接容器，容器的DNS服务可以正确的作出判断，因此如果你你需要兼容较老版本的Docker的话，那么容器test2的docker-compose.</description>
    </item>
    
    <item>
      <title>Alpha、Beta、RC、GA版本的区别</title>
      <link>https://fhxisdog.github.io/posts/alphabetarcga%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 04 Jun 2019 14:17:25 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/alphabetarcga%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description> Alpha：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。
 Beta：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。
 RC：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。
 GA:General Availability,正式发布的版本，在国外都是用GA来说明release版本的。
 RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。
 OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。
 RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。
 EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。 RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。
 α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。
  </description>
    </item>
    
    <item>
      <title>nacos使用指南</title>
      <link>https://fhxisdog.github.io/posts/nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 29 May 2019 15:33:57 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>服务启动 本地单机启动 下载源码 从github上下载源码方式: git clone https://github.com/alibaba/nacos.git cd nacos/ mvn -Prelease-nacos clean install -U ls -al distribution/target/ // change the $version to your actual path cd distribution/target/nacos-server-$version/nacos/bin  下载编译后压缩包方式 从 最新稳定版本 下载 nacos-server-$version.zip 包
 unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz cd nacos/bin  启动服务 Linux/Unix/Mac sh startup.sh -m standalone  windows cmd startup.cmd  或者双击startup.cmd运行文件。
测试 浏览器访问:localhost:8848/nacos(默认用户名/密码:nacos/nacos)
单机无数据库docker启动 下载镜像 docker pull nacos/nacos-server  启动docker docker run -d --name nacos -e PREFER_HOST_NAME=hostname -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=empty -p 8848:8848 nacos/nacos-server  docker mysql启动 新建nacos-standalone文件夹，新建standalone.</description>
    </item>
    
    <item>
      <title>skywalking使用指南</title>
      <link>https://fhxisdog.github.io/posts/skywalking%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 29 May 2019 15:33:57 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/skywalking%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>运行 单机运行  下载最新release包 解压，sh ${skywalkingpath}/bin/startup.sh 在springboot启动命令前加入启动参数
-javaagent:${path}/skywalking-agent.jar #path为skywalking解压的agent目录  访问localhost:8080查看结果
  docker 运行 前置条件 下载 下载最新release包并解压
构建docker bridge dcoker network create skywalking  使用数据库 ElasticSearch 启动es docker run -p 9200:9200 -p 9300:9300 -e &amp;quot;discovery.type=single-node&amp;quot; docker.elastic.co/elasticsearch/elasticsearch:6.4.3 #skywalking目前只支持6.x(6.1.0版本)  初始化数据库 编辑 ${path}/apache-skywalking-bin/config/appliccation.yml
storage: #elasticsearch: nameSpace: ${SW_NAMESPACE:&amp;quot;&amp;quot;} clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:dev.iotechina.com:9201} #user: ${SW_ES_USER:&amp;quot;&amp;quot;} #password: ${SW_ES_PASSWORD:&amp;quot;&amp;quot;} indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:2} indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0} #Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:2000} # Execute the bulk every 2000 requests bulkSize: ${SW_STORAGE_ES_BULK_SIZE:20} # flush the bulk every 20mb flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000} segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}  执行</description>
    </item>
    
    <item>
      <title>Manjaro I3wm接入外接显示器不显示</title>
      <link>https://fhxisdog.github.io/posts/manjaro-i3wm%E6%8E%A5%E5%85%A5%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B8%8D%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Wed, 29 May 2019 11:59:08 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/manjaro-i3wm%E6%8E%A5%E5%85%A5%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B8%8D%E6%98%BE%E7%A4%BA/</guid>
      <description>装了manjaro的i3wm桌面环境后，发现外界显示器无法显示。搜索资料后发现解决方法如下。
查看设备输入 终端输入:
xrandr  可以看到结果如下，其中 eDP1是我笔记本自带的屏幕，HDMI1就是我外接的显示器。
Screen 0: minimum 8 x 8, current 1920 x 1080, maximum 32767 x 32767 eDP1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 310mm x 170mm 1920x1080 60.05*+ 59.93 1680x1050 59.88 1400x1050 59.98 1600x900 60.00 59.95 59.82 1280x1024 60.02 1400x900 59.96 59.88 1280x960 60.00 1368x768 60.00 59.88 59.85 1280x800 59.81 59.91 1280x720 59.86 60.00 59.74 1024x768 60.00 1024x576 60.00 59.</description>
    </item>
    
    <item>
      <title>Linux使用modmap替换super和CapsLock位置</title>
      <link>https://fhxisdog.github.io/posts/linux%E4%BD%BF%E7%94%A8modmap%E6%9B%BF%E6%8D%A2super%E5%92%8Ccapslock%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Tue, 28 May 2019 15:50:39 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/linux%E4%BD%BF%E7%94%A8modmap%E6%9B%BF%E6%8D%A2super%E5%92%8Ccapslock%E4%BD%8D%E7%BD%AE/</guid>
      <description>manjaro的i3wm版本默认的mod键是super(就是windows键)，为了拯救我的小拇指，所以使用xmodmap将super键和CapsLock互换位置。
创建自己的映射表 xmodmap -pke &amp;gt; ~/.Xmodmap  创建映射 编辑～/.Xmodmap,在底部加入:
remove Lock = Caps_Lock remove Mod4 = Super_L keysym Super_L = Caps_Lock keysym Caps_Lock = Super_L add Lock = Caps_Lock add Mod4 = Super_L  测试: xmodmap ~/.Xmodmap  设置开机启动: 默认系统读取的就是$HOME/.Xmodmap
参考连接 arch-wiki
https://www.linuxidc.com/Linux/2013-05/84542.htm</description>
    </item>
    
    <item>
      <title>Smb无法连接windows共享文件夹</title>
      <link>https://fhxisdog.github.io/posts/smb%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5windows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Tue, 28 May 2019 13:05:29 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/smb%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5windows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>问题描述 使用pacmanfm在地址栏输入:smb://fhxisdog-win/temp访问windows共享文件夹，提示NO FILE OR DIRECTIONARY
在命令行使用命令:smbclient -L fhxisdog-win -U% 提示:NT_STATUS_ACCESS_DENIED
使用:smbclient -L fhxisdog-win -m SMB2可以访问
解决方法 编辑 /etc/samba/smb.conf:在[gloabl]下加入:
min protocOl = SMB2 max protocol = SMB2 client min protocol = SMB2 client max protocol = SMB2  smb简介  服务器消息块（Server Message Block，缩写为SMB），又称网络文件共享系统（Common Internet File System，缩写为CIFS, /ˈsɪfs/），一种应用层网络传输协议，由微软开发，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。它也提供经认证的行程间通信机能。它主要用在装有Microsoft Windows的机器上，在这样的机器上被称为Microsoft Windows Network。
经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。
与功能类似的网络文件系统（NFS）相比，NFS的消息格式是固定长度，而CIFS的消息格式大多数是可变长度，这增加了协议的复杂性。CIFS消息一般使用NetBIOS或TCP协议发送，分别使用不同的端口139或445，当前倾向于使用445端口。CIFS的消息包括一个信头（32字节）和消息体（1个或多个，可变长）。
 参考连接:wiki</description>
    </item>
    
    <item>
      <title>Shadowsocks-libev&#43;privoxy&#43;gfwlist2privoxy</title>
      <link>https://fhxisdog.github.io/posts/shadowsocks-libev&#43;privoxy/</link>
      <pubDate>Tue, 28 May 2019 12:01:14 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/shadowsocks-libev&#43;privoxy/</guid>
      <description>本文所用到的工具  shadowsocks-libev privoxy gfwlist2privoxy  shadowsocks-libev安装配置 下载安装:sudo pacman -S shadowsocks-libev
配置:
 在/etc/shadowsocks/下新建config.json文件 编辑config.json：
{ &amp;quot;server&amp;quot;:&amp;quot;xxxxxx&amp;quot;, #服务器IP &amp;quot;server_port&amp;quot;:xxx, #服务器端口 &amp;quot;local_address&amp;quot;:&amp;quot;127.0.0.1&amp;quot;, #本地监听IP &amp;quot;local_port&amp;quot;:1080, #本地监听端口 &amp;quot;password&amp;quot;:&amp;quot;xxx&amp;quot;, #密码 &amp;quot;method&amp;quot;:&amp;quot;xxx&amp;quot;, #加密方式 &amp;quot;fast_open&amp;quot;:false, # tcp_fastopen &amp;quot;timeout&amp;quot;:1000, #超时时间 &amp;quot;workers&amp;quot;:1 #workder进程数 }  启动ss-local: ss-local -c /etc/shadowsocks/config.json
 测试:curl -x socks5://127.0.0.1:1080 http://www.google.com
 设置守护进程启动:systemctl start shadowsocks-libev@config ** 注意：这里@config是指 /etc/shadowsocks/下面的配置文件 **
 设置开机自启动: systemctl enable shadows-libev@config
privoxy+gfwlist2privoxy安装配置 下载privoxy：sudo pacman -S privoxy
  获取 gfwlist2privoxy 脚本:curl -skL https://raw.</description>
    </item>
    
    <item>
      <title>深入浅出 JIT 编译器</title>
      <link>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</link>
      <pubDate>Sun, 21 Apr 2019 18:23:51 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</guid>
      <description>转自:https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/
JIT 简介 JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。
首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。
在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。下面我们看看，JIT 的工作过程。
JIT 编译过程 当 JIT 编译启用时（默认是启用的），JVM 读入.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码，下图展示了该过程。
图 1. JIT 工作原理图
Hot Spot 编译 当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：
首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。
当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</description>
    </item>
    
  </channel>
</rss>