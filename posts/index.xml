<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on FHXISDOG</title>
    <link>https://fhxisdog.github.io/posts/</link>
    <description>Recent content in Posts on FHXISDOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Tue, 28 May 2019 13:05:29 +0800</lastBuildDate>
    
	<atom:link href="https://fhxisdog.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Smb无法连接windows共享文件夹</title>
      <link>https://fhxisdog.github.io/posts/smb%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5windows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Tue, 28 May 2019 13:05:29 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/smb%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5windows%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>问题描述 使用pacmanfm在地址栏输入:smb://fhxisdog-win/temp访问windows共享文件夹，提示NO FILE OR DIRECTIONARY
在命令行使用命令:smbclient -L fhxisdog-win -U% 提示:NT_STATUS_ACCESS_DENIED
使用:smbclient -L fhxisdog-win -m SMB2可以访问
解决方法 编辑 /etc/samba/smb.conf:在[gloabl]下加入:
min protocOl = SMB2 max protocol = SMB2 client min protocol = SMB2 client max protocol = SMB2  smb简介  服务器消息块（Server Message Block，缩写为SMB），又称网络文件共享系统（Common Internet File System，缩写为CIFS, /ˈsɪfs/），一种应用层网络传输协议，由微软开发，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。它也提供经认证的行程间通信机能。它主要用在装有Microsoft Windows的机器上，在这样的机器上被称为Microsoft Windows Network。
经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。
与功能类似的网络文件系统（NFS）相比，NFS的消息格式是固定长度，而CIFS的消息格式大多数是可变长度，这增加了协议的复杂性。CIFS消息一般使用NetBIOS或TCP协议发送，分别使用不同的端口139或445，当前倾向于使用445端口。CIFS的消息包括一个信头（32字节）和消息体（1个或多个，可变长）。
 参考连接:wiki</description>
    </item>
    
    <item>
      <title>Shadowsocks-libev&#43;privoxy&#43;gfwlist2privoxy</title>
      <link>https://fhxisdog.github.io/posts/shadowsocks-libev&#43;privoxy/</link>
      <pubDate>Tue, 28 May 2019 12:01:14 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/shadowsocks-libev&#43;privoxy/</guid>
      <description>本文所用到的工具  shadowsocks-libev privoxy gfwlist2privoxy  shadowsocks-libev安装配置 下载安装:sudo pacman -S shadowsocks-libev
配置:
 在/etc/shadowsocks/下新建config.json文件 编辑config.json：  { &amp;quot;server&amp;quot;:&amp;quot;xxxxxx&amp;quot;, #服务器IP &amp;quot;server_port&amp;quot;:xxx, #服务器端口 &amp;quot;local_address&amp;quot;:&amp;quot;127.0.0.1&amp;quot;, #本地监听IP &amp;quot;local_port&amp;quot;:1080, #本地监听端口 &amp;quot;password&amp;quot;:&amp;quot;xxx&amp;quot;, #密码 &amp;quot;method&amp;quot;:&amp;quot;xxx&amp;quot;, #加密方式 &amp;quot;fast_open&amp;quot;:false, # tcp_fastopen &amp;quot;timeout&amp;quot;:1000, #超时时间 &amp;quot;workers&amp;quot;:1 #workder进程数 }   启动ss-local: ss-local -c /etc/shadowsocks/config.json 测试:curl -x socks5://127.0.0.1:1080 http://www.google.com 设置守护进程启动:systemctl start shadowsocks-libev@config ** 注意：这里@config是指 /etc/shadowsocks/下面的配置文件 ** 设置开机自启动: systemctl enable shadows-libev@config
privoxy+gfwlist2privoxy安装配置 下载privoxy：sudo pacman -S privoxy
  获取 gfwlist2privoxy 脚本:curl -skL https://raw.</description>
    </item>
    
    <item>
      <title>深入浅出 JIT 编译器</title>
      <link>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</link>
      <pubDate>Sun, 21 Apr 2019 18:23:51 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</guid>
      <description>转自:https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/
JIT 简介 JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。
首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。
在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。下面我们看看，JIT 的工作过程。
JIT 编译过程 当 JIT 编译启用时（默认是启用的），JVM 读入.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码，下图展示了该过程。
图 1. JIT 工作原理图
Hot Spot 编译 当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：
首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。
当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</description>
    </item>
    
  </channel>
</rss>