<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on FHXISDOG</title>
    <link>https://fhxisdog.github.io/tags/java/</link>
    <description>Recent content in java on FHXISDOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Wed, 04 Sep 2019 16:48:24 +0800</lastBuildDate>
    
	<atom:link href="https://fhxisdog.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>将vue打包到springboot静态资源中</title>
      <link>https://fhxisdog.github.io/posts/%E5%B0%86vue%E6%89%93%E5%8C%85%E5%88%B0springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%AD/</link>
      <pubDate>Wed, 04 Sep 2019 16:48:24 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/%E5%B0%86vue%E6%89%93%E5%8C%85%E5%88%B0springboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%AD/</guid>
      <description> 项目中遇到需要将vue打包到spring boot 中的static中，直接访问，不需要使用Nginx来访问nginx.具体做法如下:
将vue工程放到spring boot工程最外层 修改pom文件  &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;exec-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;!--程序打包的时候，利用本地已安装的node环境，同时编译管理后台前端的工程文件--&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;npm-build-background&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;verify&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;exec&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;executable&amp;gt;${npm.command}&amp;lt;/executable&amp;gt; &amp;lt;arguments&amp;gt; &amp;lt;argument&amp;gt;run&amp;lt;/argument&amp;gt; &amp;lt;argument&amp;gt;prod-package&amp;lt;/argument&amp;gt; &amp;lt;/arguments&amp;gt; &amp;lt;workingDirectory&amp;gt;${basedir}/consumable-background&amp;lt;/workingDirectory&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;!--添加管理后台前端工程的静态文件到jar包中--&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;copy-consumable-background&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;copy-resources&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;outputDirectory&amp;gt;${basedir}/target/classes/static/background&amp;lt;/outputDirectory&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;${basedir}/consumable-background/dist&amp;lt;/directory&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/resources&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt;  配置拦截器(此步可以省略,应为springboot static 路径是默认放开的)  @Override public void addResourceHandlers(org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry registry) { registry.addResourceHandler(&amp;quot;/static/**&amp;quot;) .addResourceLocations(&amp;quot;classpath:/static/&amp;quot;); }  </description>
    </item>
    
    <item>
      <title>Spring Boot 分环境打包</title>
      <link>https://fhxisdog.github.io/posts/spring-boot-%E5%88%86%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/</link>
      <pubDate>Wed, 04 Sep 2019 16:33:58 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/spring-boot-%E5%88%86%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/</guid>
      <description>使用spring boot工程时，虽然官方提供了application.profiles.active参数去激活不同环境，但是如果打包时忘了修改还是比较麻烦的时。可以使用maven插件，自动的更新不同环境的 的配置文件。
配置方法如下:
这里列举三个环境:dev,test,prod
resource目录结构如下(custom-config.properties为自定义的配置文件,区分不同环境也是以dev,test,prod结尾,如:custom-config-dev.properties):
--- resource --- application.yml --- application-dev.yml --- application-test.yml --- application-prod.yml --- custom-config.properties --- custom-config-dev.properties --- custom-config-test.properties --- custom-config-prod.properties --- application-common.yml  修改pom文件:  &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;dev&amp;lt;/id&amp;gt; &amp;lt;activation&amp;gt; &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt; &amp;lt;/activation&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;dev&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;test&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;test&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;prod&amp;lt;/id&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;profile.active&amp;gt;prod&amp;lt;/profile.active&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt; &amp;lt;build&amp;gt; &amp;lt;finalName&amp;gt;app&amp;lt;/finalName&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;excludes&amp;gt; &amp;lt;exclude&amp;gt;application-*.yml&amp;lt;/exclude&amp;gt; &amp;lt;exclude&amp;gt;custom-config.properties&amp;lt;/exclude&amp;gt; &amp;lt;/excludes&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt; &amp;lt;!-- 是否替换@xx@表示的maven properties属性值 --&amp;gt; &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;include&amp;gt;application.</description>
    </item>
    
    <item>
      <title>Spring Boot Thymeleaf 引用contexpath</title>
      <link>https://fhxisdog.github.io/posts/spring-boot-thymeleaf-%E5%BC%95%E7%94%A8contexpath/</link>
      <pubDate>Wed, 04 Sep 2019 16:03:04 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/spring-boot-thymeleaf-%E5%BC%95%E7%94%A8contexpath/</guid>
      <description>spring boot 设置contextPath后，如果js中的请求路径不设置，会造成404的问题。 设置方法:
在html页面header中添加配置:
&amp;lt;meta name=&amp;quot;ctx&amp;quot; th:content=&amp;quot;${#httpServletRequest.getContextPath()}&amp;quot; &amp;gt;  js中引用:
 var ctx = $(&amp;quot;meta[name=&#39;ctx&#39;]&amp;quot;).attr(&amp;quot;content&amp;quot;);  变量ctx就是contextPath</description>
    </item>
    
    <item>
      <title>nacos使用指南</title>
      <link>https://fhxisdog.github.io/posts/nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 29 May 2019 15:33:57 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/nacos%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>服务启动 本地单机启动 下载源码 从github上下载源码方式: git clone https://github.com/alibaba/nacos.git cd nacos/ mvn -Prelease-nacos clean install -U ls -al distribution/target/ // change the $version to your actual path cd distribution/target/nacos-server-$version/nacos/bin  下载编译后压缩包方式 从 最新稳定版本 下载 nacos-server-$version.zip 包
 unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz cd nacos/bin  启动服务 Linux/Unix/Mac sh startup.sh -m standalone  windows cmd startup.cmd  或者双击startup.cmd运行文件。
测试 浏览器访问:localhost:8848/nacos(默认用户名/密码:nacos/nacos)
单机无数据库docker启动 下载镜像 docker pull nacos/nacos-server  启动docker docker run -d --name nacos -e PREFER_HOST_NAME=hostname -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=empty -p 8848:8848 nacos/nacos-server  docker mysql启动 新建nacos-standalone文件夹，新建standalone.</description>
    </item>
    
    <item>
      <title>skywalking使用指南</title>
      <link>https://fhxisdog.github.io/posts/skywalking%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 29 May 2019 15:33:57 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/skywalking%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>运行 单机运行  下载最新release包 解压，sh ${skywalkingpath}/bin/startup.sh 在springboot启动命令前加入启动参数
-javaagent:${path}/skywalking-agent.jar #path为skywalking解压的agent目录  访问localhost:8080查看结果
  docker 运行 前置条件 下载 下载最新release包并解压
构建docker bridge dcoker network create skywalking  使用数据库 ElasticSearch 启动es docker run -p 9200:9200 -p 9300:9300 -e &amp;quot;discovery.type=single-node&amp;quot; docker.elastic.co/elasticsearch/elasticsearch:6.4.3 #skywalking目前只支持6.x(6.1.0版本)  初始化数据库 编辑 ${path}/apache-skywalking-bin/config/appliccation.yml
storage: #elasticsearch: nameSpace: ${SW_NAMESPACE:&amp;quot;&amp;quot;} clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:dev.iotechina.com:9201} #user: ${SW_ES_USER:&amp;quot;&amp;quot;} #password: ${SW_ES_PASSWORD:&amp;quot;&amp;quot;} indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:2} indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0} #Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:2000} # Execute the bulk every 2000 requests bulkSize: ${SW_STORAGE_ES_BULK_SIZE:20} # flush the bulk every 20mb flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000} segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}  执行</description>
    </item>
    
    <item>
      <title>深入浅出 JIT 编译器</title>
      <link>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</link>
      <pubDate>Sun, 21 Apr 2019 18:23:51 +0800</pubDate>
      
      <guid>https://fhxisdog.github.io/posts/jvm/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-jit-%E7%BC%96%E8%AF%91%E5%99%A8/</guid>
      <description>转自:https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/
JIT 简介 JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。
首先，我们大家都知道，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。
在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。下面我们看看，JIT 的工作过程。
JIT 编译过程 当 JIT 编译启用时（默认是启用的），JVM 读入.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码，下图展示了该过程。
图 1. JIT 工作原理图
Hot Spot 编译 当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：
首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。
当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</description>
    </item>
    
  </channel>
</rss>